summary(imputed_df)
# After imputation, let's check for missing values
count_imputation <- sapply(imputed_df, function(x) sum(is.na(x)))
print(count_imputation)
# Histogram for 'ethnicity' before imputation
ethnic <- ggplot(married_df, aes(x = ethnicity)) +
geom_histogram(fill = "#F7C0C8", color = "black", bins = 30) +
theme_light() +
ggtitle("Before Imputation") +
xlab("Ethnicity") +
ylab("Frequency")
# Histogram for 'ethnicity' after imputation
ethnic_imputed <- ggplot(imputed_df, aes(x = ethnicity)) +
geom_histogram(fill = "#E83853", color = "black", bins = 30) +
theme_light() +
ggtitle("After Imputation") +
xlab("Ethnicity") +
ylab("Frequency")
# Arrange the two plots side by side
grid.arrange(ethnic, ethnic_imputed, ncol = 2)
# Histogram for 'education_level' before imputation
educ <- ggplot(married_df, aes(x = education_level)) +
geom_histogram(fill = "#F7C0C8", color = "black", bins = 30) +
theme_light() +
ggtitle("Before Imputation") +
xlab("Education Level") +
ylab("Frequency")
# Histogram for 'education_level' after imputation
educ_imputed <- ggplot(imputed_df, aes(x = education_level)) +
geom_histogram(fill = "#E83853", color = "black", bins = 30) +
theme_light() +
ggtitle("After Imputation") +
xlab("Education Level") +
ylab("Frequency")
# Arrange the two plots side by side
grid.arrange(educ, educ_imputed, ncol = 2)
# Arrange the two plots side by side and capture the layout as a grob
#combined_plots <- arrangeGrob(afm_0, afm_imputed, ncol = 2)
# Now, use ggsave to save the combined plot
#ggsave("combined_age_first_marriage.png", plot = combined_plots, width = 10, height = 5)
# Convert "age at first marriage" into a binary variable to indicate child marriage
# Child marriage is defined as marriage before the age of 18
# The new binary variable "child_marriage" will have a value of 1 if the marriage occurred before age 18, and 0 otherwise
imputed_df <- imputed_df %>%
mutate(child_marriage = ifelse(age_first_marriage < 18, 1, 0))
# Create a binary variable for child marriage under 16
# The new variable "child_marriage_u16" will have a value of 1 if the marriage occurred before age 16, and 0 otherwise
imputed_df <- imputed_df %>%
mutate(child_marriage_u16 = ifelse(age_first_marriage < 16, 1, 0))
# Move "child_marriage" and "child_marriage_u16" to the front of the dataframe
imputed_df <- imputed_df %>%
dplyr::select(child_marriage, child_marriage_u16, everything())
# Exporting female_df to a CSV file in the current working directory
#write.csv(imputed_df, "imputed_df.csv", row.names = FALSE)
# Aggregate the data by region to get the total number of child marriages under 18 per region
region_counts <- aggregate(child_marriage ~ region, data = imputed_df, FUN = sum)
# Calculate the total number of child marriages under 18 in the dataset
total_child_marriages <- sum(region_counts$child_marriage)
# Calculate the percentage for each region
region_counts$married_u18_perc_of_total <- (region_counts$child_marriage / total_child_marriages) * 100
# Mapping region numbers to names
region_names <- c("Red River Delta", "Northern Midlands And Mountain",
"North Central And Central Coastal", "Central Highlands",
"South East", "Mekong River Delta")
names(region_counts)[1] <- "region_name"
region_counts$region_name <- factor(region_counts$region_name, levels = 1:6, labels = region_names)
# Display the final data frame
print(region_counts)
# Updated mapping including all provinces and cities in the Red River Delta
province_to_region <- data.frame(
NAME_1 = c(
'Bắc Ninh', 'Hà Nam', 'Hà Nội', 'Hải Dương', 'Hải Phòng', 'Hoà Bình', 'Hưng Yên', 'Nam Định', 'Ninh Bình', 'Thái Bình', 'Vĩnh Phúc', # Red River Delta 11
'Bắc Giang', 'Bắc Kạn', 'Cao Bằng', 'Hà Giang', 'Lạng Sơn', 'Lào Cai', 'Phú Thọ', 'Quảng Ninh', 'Thái Nguyên', 'Tuyên Quang', 'Yên Bái', 'Điện Biên', 'Lai Châu', 'Sơn La', # Northern Midlands And Mountain 14
'Bình Định', 'Bình Thuận', 'Khánh Hòa', 'Ninh Thuận', 'Phú Yên', 'Quảng Nam', 'Quảng Ngãi', 'Thừa Thiên Huế', 'Đà Nẵng', 'Hà Tĩnh', 'Nghệ An', 'Quảng Bình', 'Quảng Trị', 'Thanh Hóa', # North Central And Central Coastal 14
'Đắk Lắk', 'Đắk Nông', 'Gia Lai', 'Kon Tum', 'Lâm Đồng', # Central Highlands 5
'Bà Rịa - Vũng Tàu', 'Bình Dương', 'Bình Phước', 'Đồng Nai', 'Hồ Chí Minh', 'Tây Ninh', # South East 6
'An Giang', 'Bạc Liêu', 'Bến Tre', 'Cà Mau', 'Cần Thơ', 'Đồng Tháp', 'Hậu Giang', 'Kiên Giang', 'Long An', 'Sóc Trăng', 'Tiền Giang', 'Trà Vinh', 'Vĩnh Long' # Mekong River Delta 13
),
Region = c(
rep('Red River Delta', 11),
rep('Northern Midlands And Mountain', 14),
rep('North Central And Central Coastal', 14),
rep('Central Highlands', 5),
rep('South East', 6),
rep('Mekong River Delta', 13)
)
)
# Check the mapping
#print(province_to_region)
# Read shapefile
vietnam_shape <- st_read('/Users/hollyduong/Desktop/DA 401/ChildMarriageInVietnam/gadm41_VNM_shp')
# Join the shapefile with the province-to-region mapping
vietnam_shape_with_region <- vietnam_shape %>%
left_join(province_to_region, by = "NAME_1")
# Aggregate the shapefile data by region
vietnam_regions <- vietnam_shape_with_region %>%
group_by(Region) %>%
summarise(geometry = st_union(geometry), .groups = 'drop')
# Join the aggregated shapefile data with the child marriage data
vietnam_map_data <- vietnam_regions %>%
left_join(region_counts, by = c("Region" = "region_name"))
# Define colors with your specific choices
colors_ordered <- setNames(c("#B20033", "#CD0A25", "#E83853", "#EF7D8D", "#F7C0C8", "#FBE1E5"),
c("Northern Midlands And Mountain", "Central Highlands",
"Mekong River Delta", "North Central And Central Coastal",
"South East", "Red River Delta"))
# Plot
mapvn <- ggplot(data = vietnam_map_data) +
geom_sf(aes(fill = factor(Region, levels = names(colors_ordered))), color = NA) +
geom_sf_text(aes(label = sprintf("%.1f%%", married_u18_perc_of_total)), size = 4, hjust = 0.5, vjust = 0.5) +
scale_fill_manual(values = colors_ordered, name = "Region") +
labs(title = "Regional Contribution of Female Child Marriage Rates to Total Rates in Vietnam") +
theme_void() +
theme(legend.position = "right")
print(mapvn)
#ggsave("mapvn.png", plot = mapvn, width = 8, height = 6, dpi = 300)
total_child_marriages_u18 <- sum(imputed_df$child_marriage == 1)
# Aggregate counts for each category by region
counts_df <- aggregate(cbind(married_u18 = imputed_df$child_marriage == 1,
married_u16 = imputed_df$child_marriage_u16 == 1) ~ region,
data = imputed_df,
FUN = sum)
# Convert counts to percentages based on total child marriages under 18
counts_df$married_u18 <- (counts_df$married_u18 / total_child_marriages_u18) * 100
counts_df$married_u16 <- (counts_df$married_u16 / total_child_marriages_u18) * 100
p <- ggplot(counts_df, aes(x = factor(region))) +
geom_bar(aes(y = married_u18, fill = "Married before 18 years old"), stat = "identity", width = 0.5) +
geom_bar(aes(y = married_u16, fill = "Married before 16 years old"), stat = "identity", width = 0.5) +
# Adding text labels for married_u18
geom_text(aes(y = married_u18, label = sprintf("%.1f%%", married_u18)),
position = position_stack(vjust = 1.03),
size = 4, color = "black") +
# Adding text labels for married_u16
geom_text(aes(y = married_u16, label = sprintf("%.1f%%", married_u16)),
position = position_stack(vjust = 1.05),
size = 4, color = "black") +
scale_fill_manual(values = c("Married before 18 years old" = "#EF7D8D",
"Married before 16 years old" = "#B20016"),
name = "Marital Status") +
labs(x = "Region", y = "Percentage", title = "Marital Status Among Female Respondents by Region", element_text(size = 14)) +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5, size = 18),
plot.margin = margin(t = 10, r = 10, b = 10, l = 10, unit = "mm"),
axis.text.x = element_text(size = 14, angle = 45, hjust = 1),
legend.position = c(0.85,0.8),
legend.text = element_text(size = 12),
legend.title = element_text(size = 14)) +
scale_x_discrete(labels = c("1" = "Red River Delta", "2" = "Northern Midlands And Mountain",
"3" = "North Central And Central Coastal", "4" = "Central Highlands",
"5" = "South East", "6" = "Mekong River Delta"))
print(p)
#ggsave("marital_status.png", plot = p, width = 10, height = 5)
# Calculate correlation matrix
cor_matrix <- cor(imputed_df %>% select_if(is.numeric), use = "complete.obs")
# Melt the correlation matrix
melted_cor_matrix <- melt(cor_matrix)
# Generate an interactive heatmap
corr_matrix <- ggplot(melted_cor_matrix, aes(Var1, Var2, fill = value)) +
geom_tile() +
scale_fill_gradientn(
colours = c("deepskyblue", "white", "#CD0A25"),
values = scales::rescale(c(-1, 0, 1)),
limits = c(-1, 1),
name="Pearson\nCorrelation"
) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
xlab("") +
ylab("") +
ggtitle("Correlation Matrix")
# Convert ggplot object to plotly for interactivity
ggplotly(corr_matrix)
#write.csv(imputed_df, "imputed_df.csv", row.names = FALSE)
# Convert nominal and ordinal variables to factors
imputed_df$area <- as.factor(imputed_df$area)
imputed_df$region <- as.factor(imputed_df$region)
imputed_df$education_level <- factor(imputed_df$education_level, ordered = FALSE)
imputed_df$ethnicity <- as.factor(imputed_df$ethnicity)
imputed_df$wealth_index <- factor(imputed_df$wealth_index, ordered = FALSE)
# Binary variables are already in the correct format and can be used as is
# Baseline model for reference
baseline_model <- glm(child_marriage ~ area + education_level + wealth_index + health_insurance + current_contraceptive_use + awareness_hiv_aids + access_to_media, family = binomial(), data = imputed_df)
# Summarize the baseline model
summary(baseline_model)
# Enhanced model with additional fixed effects
enhanced_model <- glm(child_marriage ~ area + region + education_level + ethnicity + wealth_index + health_insurance + current_contraceptive_use + awareness_hiv_aids + access_to_media,
family = binomial(),
data = imputed_df)
# Summarize the new model with FEs
summary(enhanced_model)
# Adding the interaction term between ethnicity and access_to_media
model_interaction <- update(enhanced_model, . ~ . + ethnicity:access_to_media)
summary(model_interaction)
# Function to add significance asterisks
add_asterisks <- function(p_value) {
if (is.na(p_value)) {
return(NA)
} else if (p_value < 0.001) {
return("***")
} else if (p_value < 0.01) {
return("**")
} else if (p_value < 0.05) {
return("*")
} else {
return("")
}
}
# Function to format confidence intervals as a string
format_ci <- function(lower, upper) {
paste0("(", round(lower, 2), ", ", round(upper, 2), ")")
}
# Tidy the baseline model with confidence intervals
tidy_baseline <- tidy(baseline_model, conf.int = TRUE, exponentiate = TRUE)
# Tidy the enhanced model with confidence intervals
tidy_enhanced <- tidy(enhanced_model, conf.int = TRUE, exponentiate = TRUE)
# Tidy the interaction model with confidence intervals
tidy_interaction <- tidy(model_interaction, conf.int = TRUE, exponentiate = TRUE)
# Apply the function to each model's p.value
tidy_baseline$asterisks <- sapply(tidy_baseline$p.value, add_asterisks)
tidy_enhanced$asterisks <- sapply(tidy_enhanced$p.value, add_asterisks)
tidy_interaction$asterisks <- sapply(tidy_interaction$p.value, add_asterisks)
# Create OR strings with asterisks and format CIs as a string
tidy_baseline <- tidy_baseline %>%
mutate(
OR = ifelse(is.na(estimate), NA, paste0(round(estimate, 2), asterisks)),
CI = ifelse(is.na(conf.low) | is.na(conf.high), NA, format_ci(conf.low, conf.high))
)
tidy_enhanced <- tidy_enhanced %>%
mutate(
OR = ifelse(is.na(estimate), NA, paste0(round(estimate, 2), asterisks)),
CI = ifelse(is.na(conf.low) | is.na(conf.high), NA, format_ci(conf.low, conf.high))
)
tidy_interaction <- tidy_interaction %>%
mutate(
OR = ifelse(is.na(estimate), NA, paste0(round(estimate, 2), asterisks)),
CI = ifelse(is.na(conf.low) | is.na(conf.high), NA, format_ci(conf.low, conf.high))
)
# Add a 'Model' column to each tidied dataframe
tidy_baseline <- tidy_baseline %>% mutate(Model = "Model_1")
tidy_enhanced <- tidy_enhanced %>% mutate(Model = "Model_2")
tidy_interaction <- tidy_interaction %>% mutate(Model = "Model_3")
# Combine and pivot the dataframes
combined_results <- bind_rows(
tidy_baseline %>% dplyr::select(term, OR, CI, Model),
tidy_enhanced %>% dplyr::select(term, OR, CI, Model),
tidy_interaction %>% dplyr::select(term, OR, CI, Model)
) %>%
pivot_wider(names_from = Model, values_from = c(OR, CI))
# Replace NAs with "—"
combined_results[is.na(combined_results)] <- "—"
# Reordering columns to have OR and CI next to each other for each model
combined_results <- combined_results %>%
dplyr::select(term,
OR_Model_1, CI_Model_1,
OR_Model_2, CI_Model_2,
OR_Model_3, CI_Model_3)
# Print the final combined table
print(combined_results)
# Model 1 vs. Model 2
anova(baseline_model, enhanced_model, test="Chisq")
# Model 1 vs. Model 3
anova(baseline_model, model_interaction, test="Chisq")
# Model 2 vs. Model 3
anova(enhanced_model, model_interaction, test="Chisq")
invisible(plot(roc(imputed_df$child_marriage,
fitted(baseline_model)),
col = "red",
main = "ROC Curve: \nModel 1 (red) vs. Model 2 (green) vs. Model 3 (blue)"))
invisible(plot(roc(imputed_df$child_marriage,
fitted(enhanced_model)),
col = "green",
add = T))
invisible(plot(roc(imputed_df$child_marriage,
fitted(model_interaction)),
print.auc = T,
col = "blue",
add = T))
# For each model
roc_response_model_1 <- roc(imputed_df$child_marriage, fitted(baseline_model))
auc_model_1 <- auc(roc_response_model_1)
roc_response_model_2 <- roc(imputed_df$child_marriage, fitted(enhanced_model))
auc_model_2 <- auc(roc_response_model_2)
roc_response_model_3 <- roc(imputed_df$child_marriage, fitted(model_interaction))
auc_model_3 <- auc(roc_response_model_3)
# Compare AUC values
print(paste("AUC Model 1:", auc_model_1))
print(paste("AUC Model 2:", auc_model_2))
print(paste("AUC Model 3:", auc_model_3))
binnedplot(fitted(model_interaction),
residuals(model_interaction, type = "response"),
nclass = NULL,
xlab = "Expected Values",
ylab = "Average Residuals",
main = "Binned Residual Plot",
cex.pts = 1,
col.int = "gray")
# 1. Hosmer-Lemeshow Test for the Model 1
hoslem.test(baseline_model$y, fitted(baseline_model), g=10)
# 2. Hosmer-Lemeshow Test for the Model 2 (Baseline + Fixed Effects)
hoslem.test(enhanced_model$y, fitted(enhanced_model), g=10)
# 3. Hosmer-Lemeshow Test for the Model 3 (Baseline + Fixed Effects + Interaction Terms)
hoslem.test(model_interaction$y, fitted(model_interaction), g=10)
# VIFs check (A VIF value > 5 indicates high multicollinearity)
# Base model
model_1_vif <- vif(baseline_model)
print(model_1_vif)
# Enhanced model
model_2_vif <- vif(enhanced_model)
print(model_2_vif)
# Interacton model
model_3_vif <- vif(model_interaction)
print(model_3_vif)
# Create a data frame to hold AIC and BIC values
aic_bic_comparison <- data.frame(
Model = c("Model 1", "Model 2", "Model 3"),
AIC = c(AIC(baseline_model), AIC(enhanced_model), AIC(model_interaction)),
BIC = c(BIC(baseline_model), BIC(enhanced_model), BIC(model_interaction))
)
# Print the table
print(aic_bic_comparison)
# No imputation -- Remove rows with any missing data from 'female_df'
og_df <- na.omit(married_df)
print(og_df)
# Convert "age at first marriage" into a binary variable to indicate child marriage
# Child marriage is defined as marriage before the age of 18
# The new binary variable "child_marriage" will have a value of 1 if the marriage occurred before age 18, and 0 otherwise
og_df <- og_df %>%
mutate(child_marriage = ifelse(age_first_marriage < 18, 1, 0))
# Create a binary variable for child marriage under 16
# The new variable "child_marriage_u16" will have a value of 1 if the marriage occurred before age 16, and 0 otherwise
og_df <- og_df %>%
mutate(child_marriage_u16 = ifelse(age_first_marriage < 16, 1, 0))
# Move "child_marriage" and "child_marriage_u16" to the front of the dataframe
og_df <- og_df %>%
dplyr::select(child_marriage, child_marriage_u16, everything())
# Convert nominal and ordinal variables to factors
og_df$area <- as.factor(og_df$area)
og_df$region <- as.factor(og_df$region)
og_df$education_level <- factor(og_df$education_level, ordered = FALSE)
og_df$ethnicity <- as.factor(og_df$ethnicity)
og_df$wealth_index <- factor(og_df$wealth_index, ordered = FALSE)
# Binary variables are already in the correct format and can be used as is
#write.csv(og_df, "og_df.csv", row.names = FALSE)
# Base model
base_model_no_impute <- glm(child_marriage ~ area + education_level + wealth_index + health_insurance + current_contraceptive_use + awareness_hiv_aids + access_to_media, family = binomial(), data = og_df)
# Summarize the base model
summary(base_model_no_impute)
# Enhanced model with additional fixed effects
enhanced_model_no_impute <- glm(child_marriage ~ area + region + education_level + ethnicity + wealth_index + health_insurance + current_contraceptive_use + awareness_hiv_aids + access_to_media, family = binomial(), data = og_df)
# Summarize the new model with FEs
summary(enhanced_model_no_impute)
# Adding the interaction term between education level and wealth index
interaction_model_no_impute <- update(enhanced_model_no_impute, . ~ . + ethnicity:access_to_media)
summary(interaction_model_no_impute)
# Extracting data from the models
extract_model_data <- function(model) {
model_summary <- summary(model)
coeffs <- model_summary$coefficients
data.frame(
Term = rownames(coeffs),
Estimate = sprintf("%.3f", coeffs[, "Estimate"]),
pValue = ifelse(coeffs[, "Pr(>|z|)"] < 0.001,
format(coeffs[, "Pr(>|z|)"], scientific = TRUE),
sprintf("%.3f", coeffs[, "Pr(>|z|)"])),
Significance = sapply(coeffs[, "Pr(>|z|)"], add_asterisks)
)
}
# Applying the function to each model
base_impute_data <- extract_model_data(baseline_model)
base_no_impute_data <- extract_model_data(base_model_no_impute)
# Combine the data for comparison
base_comparison_data <- merge(base_impute_data, base_no_impute_data, by = "Term", suffixes = c("_Impute", "_NoImpute"), sort = FALSE)
# View the comparison
print(base_comparison_data)
# Applying the function to each model
enhanced_impute_data <- extract_model_data(enhanced_model)
enhanced_no_impute_data <- extract_model_data(enhanced_model_no_impute)
# Combine the data for comparison
enhanced_comparison_data <- merge(enhanced_impute_data, enhanced_no_impute_data, by = "Term", suffixes = c("_Impute", "_NoImpute"), sort = FALSE)
# View the comparison
print(enhanced_comparison_data)
# Applying the function to each model
interaction_impute_data <- extract_model_data(model_interaction)
interaction_no_impute_data <- extract_model_data(interaction_model_no_impute)
# Combine the data for comparison
interaction_comparison_data <- merge(interaction_impute_data, interaction_no_impute_data, by = "Term", suffixes = c("_Impute", "_NoImpute"), sort = FALSE)
# View the comparison
print(interaction_comparison_data)
# Tidy the baseline model with confidence intervals
tidy_base_no_impute <- tidy(base_model_no_impute, conf.int = TRUE, exponentiate = TRUE)
# Tidy the enhanced model with confidence intervals
tidy_enhanced_no_impute <- tidy(enhanced_model_no_impute, conf.int = TRUE, exponentiate = TRUE)
# Tidy the interaction model with confidence intervals
tidy_interaction_no_impute <- tidy(interaction_model_no_impute, conf.int = TRUE, exponentiate = TRUE)
# Apply the function to each model's p.value
tidy_base_no_impute$asterisks <- sapply(tidy_base_no_impute$p.value, add_asterisks)
tidy_enhanced_no_impute$asterisks <- sapply(tidy_enhanced_no_impute$p.value, add_asterisks)
tidy_interaction_no_impute$asterisks <- sapply(tidy_interaction_no_impute$p.value, add_asterisks)
# Create OR strings with asterisks and format CIs as a string
tidy_base_no_impute <- tidy_base_no_impute %>%
mutate(
OR = ifelse(is.na(estimate), NA, paste0(round(estimate, 2), asterisks)),
CI = ifelse(is.na(conf.low) | is.na(conf.high), NA, format_ci(conf.low, conf.high))
)
tidy_enhanced_no_impute <- tidy_enhanced_no_impute %>%
mutate(
OR = ifelse(is.na(estimate), NA, paste0(round(estimate, 2), asterisks)),
CI = ifelse(is.na(conf.low) | is.na(conf.high), NA, format_ci(conf.low, conf.high))
)
tidy_interaction_no_impute <- tidy_interaction_no_impute %>%
mutate(
OR = ifelse(is.na(estimate), NA, paste0(round(estimate, 2), asterisks)),
CI = ifelse(is.na(conf.low) | is.na(conf.high), NA, format_ci(conf.low, conf.high))
)
# Add a 'Model' column to each tidied dataframe
tidy_base_no_impute <- tidy_base_no_impute %>% mutate(Model = "Model_1")
tidy_enhanced_no_impute <- tidy_enhanced_no_impute %>% mutate(Model = "Model_2")
tidy_interaction_no_impute <- tidy_interaction_no_impute %>% mutate(Model = "Model_3")
# Combine and pivot the dataframes
combined_no_impute <- bind_rows(
tidy_base_no_impute %>% dplyr::select(term, OR, CI, Model),
tidy_enhanced_no_impute %>% dplyr::select(term, OR, CI, Model),
tidy_interaction_no_impute %>% dplyr::select(term, OR, CI, Model)
) %>%
pivot_wider(names_from = Model, values_from = c(OR, CI))
# Replace NAs with "—"
combined_no_impute[is.na(combined_no_impute)] <- "—"
# Reordering columns to have OR and CI next to each other for each model
combined_no_impute <- combined_no_impute %>%
dplyr::select(term,
OR_Model_1, CI_Model_1,
OR_Model_2, CI_Model_2,
OR_Model_3, CI_Model_3)
# Print the final combined table
print(combined_no_impute)
# Model 1 vs. Model 2
anova(base_model_no_impute, enhanced_model_no_impute, test="Chisq")
# Model 1 vs. Model 3
anova(base_model_no_impute, interaction_model_no_impute, test="Chisq")
# Model 2 vs. Model 3
anova(enhanced_model_no_impute, interaction_model_no_impute, test="Chisq")
invisible(plot(roc(og_df$child_marriage,
fitted(base_model_no_impute)),
col = "red",
main = "ROC Curve: \nModel 1 (red) vs. Model 2 (green) vs. Model 3 (blue)"))
invisible(plot(roc(og_df$child_marriage,
fitted(enhanced_model_no_impute)),
col = "green",
add = T))
invisible(plot(roc(og_df$child_marriage,
fitted(interaction_model_no_impute)),
print.auc = T,
col = "blue",
add = T))
# For each model
roc_response_model_1 <- roc(og_df$child_marriage, fitted(base_model_no_impute))
auc_model_1 <- auc(roc_response_model_1)
roc_response_model_2 <- roc(og_df$child_marriage, fitted(enhanced_model_no_impute))
auc_model_2 <- auc(roc_response_model_2)
roc_response_model_3 <- roc(og_df$child_marriage, fitted(interaction_model_no_impute))
auc_model_3 <- auc(roc_response_model_3)
# Compare AUC values
print(paste("AUC Model 1:", auc_model_1))
print(paste("AUC Model 2:", auc_model_2))
print(paste("AUC Model 3:", auc_model_3))
binnedplot(fitted(interaction_model_no_impute),
residuals(interaction_model_no_impute, type = "response"),
nclass = NULL,
xlab = "Expected Values",
ylab = "Average Residuals",
main = "Binned Residual Plot",
cex.pts = 1,
col.int = "gray")
# 1. Hosmer-Lemeshow Test for the Model 1
hoslem.test(base_model_no_impute$y, fitted(base_model_no_impute), g=10)
# 2. Hosmer-Lemeshow Test for the Model 2 (Baseline + Fixed Effects)
hoslem.test(enhanced_model_no_impute$y, fitted(enhanced_model_no_impute), g=10)
# 3. Hosmer-Lemeshow Test for the Model 3 (Baseline + Fixed Effects + Interaction Terms)
hoslem.test(interaction_model_no_impute$y, fitted(interaction_model_no_impute), g=10)
# VIFs check (A VIF value > 5 indicates high multicollinearity)
# Base model
model_1_vif <- vif(base_model_no_impute)
print(model_1_vif)
# Enhanced model
model_2_vif <- vif(enhanced_model_no_impute)
print(model_2_vif)
# Interacton model
model_3_vif <- vif(interaction_model_no_impute)
print(model_3_vif)
# Create a data frame to hold AIC and BIC values
aic_bic_comparison <- data.frame(
Model = c("Model 1", "Model 2", "Model 3"),
AIC = c(AIC(base_model_no_impute), AIC(enhanced_model_no_impute), AIC(interaction_model_no_impute)),
BIC = c(BIC(base_model_no_impute), BIC(enhanced_model_no_impute), BIC(interaction_model_no_impute))
)
# Print the table
print(aic_bic_comparison)
mod <- glm(child_marriage ~ area + region + education_level + ethnicity + wealth_index + health_insurance + current_contraceptive_use + awareness_hiv_aids + access_to_media, wealth_index:education_level,
family = binomial(),
data = og_df)
# Adding the interaction term between education level and wealth index
interaction_model_no_impute <- update(enhanced_model_no_impute, . ~ . + wealth_index:education_level)
summary(interaction_model_no_impute)
# Adding the interaction term between education level and wealth index
interaction_model_no_impute <- update(enhanced_model_no_impute, . ~ . + ethnicity:education_level)
summary(interaction_model_no_impute)
# Adding the interaction term between education level and wealth index
interaction_model_no_impute <- update(enhanced_model_no_impute, . ~ . + ethnicity:wealth_index)
summary(interaction_model_no_impute)
# Adding the interaction term between education level and wealth index
interaction_model_no_impute <- update(enhanced_model_no_impute, . ~ . + ethnicity:access_to_media)
summary(interaction_model_no_impute)
